# Kernel-module initialization

The kernel, currently, follows the ELF ABI for loading and linking modules. Efforts have been made in the direction to simplify the kernel-module developmeent process and make the environment fairly similar to user-space libraries, there are a few exceptions where kernel-module developers must look into.

## Module-loader based initialization

To understand how your module initialization, you must know how the `ModuleLoader` class interacts with your modules' container. During linking, the `__DYNAMIC__` is extracted and any useful information is kept with the `ModuleContainer`. Same occurs with the initialization/finalization functions.

While developing with the ELF ABI, your module will declare a three step initialization process:

1. First the `ModuleLoader` will call functions in the `__preinit` array. This is not handled by your code, and only the compiler-chain inserts its functions here. It is uncommon to have any functors present in this array. You don't have to worry about this, but still, the module-loader will call functors from this array, if they exist.

2. Secondly, the `_init()` function will be called. This is generally given by the compiler to do stuff before calling any C++ constructors. Your module may bypass this function, if you want to go against the ABI, by declaring another function called `__init()` that will be executed on behalf of `_init()`. Note that ``_init()` is generated by the compiler-chain and `__init()` is declared by the developer (optionally) to bypass `_init()` and do all initializations on their own. This is generally not useful and shouldn't be done.

3. Thirdly, the `__init` array is used to call all C++ object constructors plus any C constructors declared by the kernel-module developer. The `ModuleLoader` also calls functions in this.

## Declaring primitive types before C++ objects use them

Generally, low-level structs are allocated by slab allocators, and therefore the underlying `ObjectInfo` structures must be allocated before any C++ object actually uses it to gain access to those heap-allocated structs. Although your compiler-chain may not support declaring `__preinit` functions, it should allow you to specify C++ constructor priorities. Your C initialization sequence should have a higher priority than the C++ object constructors.

### Standard priorities for constructor functions

1. 100 - C function initializing any slab-allocator `ObjectInfo` type.

2. none - C++ objects.

(more to be standardized once they are used)